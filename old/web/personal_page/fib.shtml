<!DOCTYPE html>

<html lang = "en">

	<head>

	    <meta charset = "utf-8">
	    <meta name = "viewport" content = "width=device-width, initial-scale=1">
		<meta name = "author" content = "anon">

	    <title>rekt.undo.it</title>

	    <!-- cache fonts from google -->
	    <link rel = "stylesheet" href = "http://fonts.googleapis.com/css?family=Libre+Barcode+39+Text|VT323|Source+Code+Pro" />

	    <!-- custom sheet loads last -->
	    <link href = "default.css" rel = "stylesheet" />

	</head>

	<script type ="text/javascript">
  		function sfToggle() {
  			if (screenfetch.style.display == 'block') {
  				screenfetch.style.display = 'none';
  			}
  			else {
  				screenfetch.style.display = 'block';
  			}
  		}
  	</script>

	<body class = "stambul">

	    <div id = "main_body">

	    	<div class = "main_header">

				<div class = "mast">
					<div class = "mast_h1">rekt.undo.it</div>
					<div class = "mast_h2"><a href="index.shtml">news</a></div>
					<div class = "mast_h2">
						<a href = "#" onclick = "sfToggle(); return false">screenfetch</a>
					</div>
					<div class = "mast_h2"><a href="resources.shtml">resources</a></div>
					<div class = "mast_h2"><a href="jnug_reversion.txt">jnug reversion</a></div>
					<div class = "mast_h2"><a href="901.shtml">901</a></div>
					<div class = "mast_h2"><a href="902.shtml">902</a></div>
				</div>

			</div>

			<div id = "screenfetch"><!--#include virtual = "/screenfetch.txt"> --></div>

			<div class = "main_news">

				<div class = "main_h2">fibonacci algorithms revisited (C#).</div>
				<div class = "main_block_text">Hosting a requested explanation of an older programming project. Originally written in Java, then ported to C# for 128-bit datatypes and easier UI design in Visual Studio.
					<ul style = "list-style-type: none; margin-bottom: 5%">
						<li><a href = "#array">recursive array</a></li>
						<li><a href = "#recursion">recursion</a></li>
						<li><a href = "#iteration">iteration</a></li>
						<li><a href = "fibonacci_2.csharp">full source</a></li>
					</ul>


				</div>

				<div class = "main_h2"><a id = "array"></a>recursive array.</div>
				<div class = "main_block_text">An array of the proper length is generated, and each field is populated with the corresponding sequence element via the GiveRecurse() method. Each element is still generated independently of all other elements, but the overall sequence is generated only once.</div>
				<pre class = "preformat">private decimal[] PopulateRecurseArray(int nth)
{
	decimal[] recursiveArray = new decimal[nth];
	int i = (int)first;
	recursiveArray[0] = 0; // <- unneeded, forgot to remove in the source
	while (i < nth)
	{
		recursiveArray[i] = GiveRecurse(i);
		i++;
	}
	return</pre>

				<div class = "main_block_text">The iterative output method first calls the population method and then prints each sequence element. Even though this method is iterative, output appears as one blob of text since population is done before anything is displayed. Even so, this approach is drastically quicker: on my machine the 40th element was generated in 22.6 seconds compared to the 46.3 second required by pure recursion.</div>
				<pre class = "preformat" style = "margin-bottom: 5%">private void RecurseArray(int input)
{
	timeOp.Start();
	decimal[] recurseArray =  PopulateRecurseArray(input+1);
	int i = first;
	while (i <= input)
	{
		if (recurseArray[i] == -1)
		{
			outputListBox.Items.Add("Overflow error at element " + (i) + ". The element's value is too large to calculate.   Elapsed time: " + ((decimal)timeOp.ElapsedMilliseconds / 1000) + " seconds.");
			outputListBox.TopIndex = outputListBox.Items.Count - 1;
		}
		else
		{
			outputListBox.Items.Add("Sequence element " + (i) + " is " + recurseArray[i] + ".   Elapsed time: " + ((decimal)timeOp.ElapsedMilliseconds / 1000) + " seconds.");
			outputListBox.TopIndex = outputListBox.Items.Count - 1;
		}
		i++;
	}
	timeOp.Reset();</pre>

				<div class = "main_h2"><a id = "recursion"></a>recursive.</div>
				<div class = "main_block_text">The recursive method is compact and elegant, but in this case economy of code translates into horrible inefficiency, as each element is generated independently. Example: to find the 5th element, it finds the 4th and 3rd; the 4th must be generated by finding the 3rd and 2nd; the 3rd is generated by finding the 2nd and 1st, etc. Each and every element is determined by independently generating the two previous elements with no reference to any previous calculations, so even though it is simple addition, the number of operations rises as the depth of the elements increases. My desktop bogged down somewhere around the 40th element and I lacked the courage to attempt overflowing the datatype (I assume an overflow would be caught by the try-catch error-checking, as it is implemented and operational in the iterative method).</div>
				<pre class = "preformat" style = "margin-bottom: 5%">private decimal GiveRecurse(int nth)
{
	// base case: zero, one.
	if (nth == 0 || nth == 1)
	{
		return nth;
	}
	else
	{
		try
		{
			decimal recurseToGive = GiveRecurse(nth - 1) + GiveRecurse(nth - 2);
			return recurseToGive;
		}
		// overflow catch.
		// returns value (-1) which is not otherwise generated,
		// which is then checked by the calling method (RecurseZero() or RecurseOne()).
		catch
		{
			return -1;
		}
	}
}</pre>

				<div class = "main_h2"><a id = "iteration"></a>iterative.</div>
				<div class = "main_block_text">Simple variable replacement as the method steps through each iteration of the loop. Doesn't look as cool, but calculates the elements quickly no matter the depth (until the decimal overflows).</div>
				<pre class = "preformat" style = "margin-bottom: 5%">private decimal GiveIterate(int nth)
{
	// base case: zero, one.
	if ((nth == 0) || (nth == 1))
	{
		return nth;
	}
	else
	{
		try
		{
			decimal first = 0;
			decimal second = 1;
			decimal fibonacci = 0;
			int count = 2;
			while (count <= nth)
			{
				fibonacci = first + second;
				first = second;
				second = fibonacci;
				count++;
			}
			return second;
		}
		// catches overflow and returns value (-1) which is not otherwise generated,
		// which is then checked by the calling method (IterateZero() or IterateOne()).
		catch
		{
			return -1;
		}
	}
}</pre>

				<div class = "main_block_text">Accuracy was checked against the known sequence of Fibonacci numbers that could be contained in the decimal datatype. See '<a href = "http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibtable.html">The first 300 Fibonacci numbers, factored</a>' for more information.</div>
				<div class = "main_block_text">You can find the source code in its entirety <a href = "fibonacci_2.csharp">here</a>.</div>

			</div>

			<div class="main_footer">
	    		<div class="in_footer_left">Dynamic DNS provided by <a href="http://freedns.afraid.org/">Free DNS</a>. rekt.undo.it<!--#echo var="DOCUMENT_URI" -->, served <!--#echo var="DATE_LOCAL"-->.</div>
	    		<div class="in_footer_right">plsnosteal.</div>
	    	</div>
		
		</div>

	</body>
  
</html>