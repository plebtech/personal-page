<!DOCTYPE html>

<html lang="en" />

  <head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta name="author" content="Nick McGlawn" />

    <title>Fibonacci algorithms - by NickMc</title>

    <!-- bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet" />

    <!-- cache fonts from google -->
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Gloria+Hallelujah|Yanone+Kaffeesatz|Goudy+Bookletter+1911" />

    <!-- custom sheet loads last -->
    <link href="default.css" rel="stylesheet" />

    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
      <![endif]-->

  </head>

  <body class = "wires" style="text-align: center; background-color: #fff;">

    <div class = "container" id = "main_body">
	
		<div class="row main_header">
		
			<div class = "mast span4">
				<!--#include file = "mast.html" -->
			</div>
			
		</div>
		
		<div class = "main_news">
		
			<div class = "row no2lite">
				<div class = "main_h1">Fibonacci algorithms revisited</div>
			</div>
			
			<div class = "row">
				<div class = "main_h2">Recursive Array</div>
			</div>
			<div class = "row"><div class = "main_block_text">
				An array of the proper length is generated, and each field is populated with the corresponding sequence element via the GiveRecurse() method. Each element is still generated independently of all other elements, but the overall sequence is generated only once.
			</div></div>	
			<div class = "row">
				<div class = "main_block_text">
					<pre style = "border: 1px solid grey; padding: 5px; white-space: pre-wrap">
private decimal[] PopulateRecurseArray(int nth)
{
	decimal[] recursiveArray = new decimal[nth];
	int i = (int)first;
	recursiveArray[0] = 0; // <- unneeded, forgot to remove in the source
	while (i < nth)
	{
		recursiveArray[i] = GiveRecurse(i);
		i++;
	}
	return
					</pre>
				</div>
			</div>		
			
			<div class = "row"><div class = "main_block_text">
				The iterative output method first calls the population method and then prints each sequence element. Even though this method is iterative, output appears as one blob of text since population is done before anything is displayed (and display is handled quickly in comparison). Even so, this approach is drastically quicker: on my machine the 40th element was generated in 22.6 seconds compared to the 46.3 seconds required by pure recursion.
			</div></div>				
			<div class = "row">
				<div class = "main_block_text">
					<pre style = "border: 1px solid grey; padding: 5px; white-space: pre-wrap">
private void RecurseArray(int input)
{
	timeOp.Start();
	decimal[] recurseArray =  PopulateRecurseArray(input+1);
	int i = first;
	while (i <= input)
	{
		if (recurseArray[i] == -1)
		{
			outputListBox.Items.Add("Overflow error at element " + (i) + ". The element's value is too large to calculate.   Elapsed time: " + ((decimal)timeOp.ElapsedMilliseconds / 1000) + " seconds.");
			outputListBox.TopIndex = outputListBox.Items.Count - 1;
		}
		else
		{
			outputListBox.Items.Add("Sequence element " + (i) + " is " + recurseArray[i] + ".   Elapsed time: " + ((decimal)timeOp.ElapsedMilliseconds / 1000) + " seconds.");
			outputListBox.TopIndex = outputListBox.Items.Count - 1;
		}
		i++;
	}
	timeOp.Reset();
}
					</pre>
				</div>
			</div>

			<div class = "row">
				<div class = "main_h2">Recursive</div>
			</div>
			
			<div class = "row"><div class = "main_block_text">
				The recursive method is compact and elegant, but in this case economy of code translates into horrible inefficiency, as each element is generated independently. Example: to find the 5th element, it finds the 4th and 3rd; the 4th must be generated by finding the 3rd and 2nd; the 3rd is generated by finding the 2nd and 1st, etc. Each and every element is determined by independently generating the two previous elements with no reference to any previous calculations, so even though it is simple addition, the number of operations rises as the depth of the elements increases. My desktop bogged down somewhere around the 40th element and I lacked the courage to attempt overflowing the datatype (I assume an overflow would be caught by the try-catch error-checking, as it is implemented and operational in the iterative method).
			</div></div>
			
			<div class = "row">
				<div class = "main_block_text">
					<pre style = "border: 1px solid grey; padding: 5px; white-space: pre-wrap">
        private decimal GiveRecurse(int nth)
        {
            // base case: zero, one.
            if (nth == 0 || nth == 1)
            {
                return nth;
            }
            else
            {
                try
                {
                    decimal recurseToGive = GiveRecurse(nth - 1) + GiveRecurse(nth - 2);
                    return recurseToGive;
                }
                // overflow catch.
                // returns value (-1) which is not otherwise generated,
                // which is then checked by the calling method (RecurseZero() or RecurseOne()).
                catch
                {
                    return -1;
                }
            }
        }
					</pre>
				</div>
			</div>

			
			<div class = "row">
				<div class = "main_h2">Iterative</div>
			</div>
			
			
			<div class = "row"><div class = "main_block_text">
				Simple variable replacement as the method steps through each iteration of the loop. Doesn't look as cool, but calculates the elements quickly no matter the depth (until the decimal overflows).
			</div></div>
			
			<div class = "row">
				<div class = "main_block_text">
					<pre style = "border: 1px solid grey; padding: 5px; white-space: pre-wrap">
        private decimal GiveIterate(int nth)
        {
            // base case: zero, one.
            if ((nth == 0) || (nth == 1))
            {
                return nth;
            }
            else
            {
                try
                {
                    decimal first = 0;
                    decimal second = 1;
                    decimal fibonacci = 0;
                    int count = 2;
                    while (count <= nth)
                    {
                        fibonacci = first + second;
                        first = second;
                        second = fibonacci;
                        count++;
                    }
                    return second;
                }
                // catches overflow and returns value (-1) which is not otherwise generated,
                // which is then checked by the calling method (IterateZero() or IterateOne()).
                catch
                {
                    return -1;
                }
            }
        }
					</pre>
				</div>
			</div>

			
			<div class = "row">
				<div class = "main_h2">Notes</div>
			</div>
			<div class = "row"><div class = "main_block_text">
				Accuracy was checked against the known sequence of Fibonacci numbers that could be contained in the decimal datatype. See '<a href = "http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibtable.html">The first 300 Fibonacci numbers, factored</a>' for more information.
			</div></div>
			<div class = "row" style = "margin-top: 10px;"><div class = "main_block_text">
				You can find the source code in its entirety <a href = "fibonacci_2.csharp">here</a>.
			</div></div>
		
		</div>

      <div class="row main_footer">
        <div class="span6 in_footer_left"><a href="http://www.bynickmc.com">bynickmc.com</a></div>
        <div class="span6 in_footer_right">Copyright 2016. All rights reserved.</div>
      </div>
	
	</div>

  </body>
  
</html>